import json
import yaml
import jinja2
import j2test.commons.utils_messages as utils_messages
from deepdiff import DeepDiff
from typing import Dict

from j2test.filters.assert_global import assert_func
from j2test.filters.base64_filter import base64_encode, base64_decode
from j2test.filters.file_filter import read_from_file, write_to_file_filter
from j2test.filters.from_json import from_json_filter
from j2test.filters.jsonmerge import jsonmerge_filter
from j2test.filters.jsonpath import jsonpath_filter
from j2test.filters.simple_to_json import simple_to_json_filter
from j2test.filters.very_strict_undefined import VeryStrictUndefined
from j2test.filters.yaml_filter import from_yaml_filter, to_yaml_filter
from j2test.filters.regex_replace import regex_replace
import j2test.filters.hcl as hcl


def get_template(template_path: str, env_path: str) -> jinja2.Template:
    """
        Gets the Jinja2 template in Python using the Jinja2 API.

        :param template_path: Path to template file relative to env_path
        :type args: str

        :param env_path: Base directory in which all jinja files are located within
        :type env_path: str

        :return: Jinja2 template if found
        :rtype: jinja2.Template
    """
    env = _get_env(env_path)

    try:
        template = env.get_template(template_path)
        return template
    except jinja2.exceptions.TemplateNotFound:
        print(utils_messages.TEMPLATE_NOT_FOUND.format(template_path=template_path))
    except jinja2.exceptions.TemplateSyntaxError as e:
        print(utils_messages.TEMPLATE_SYNTAX_ERR.format(path=template_path, e=e))


def get_macro(template: jinja2.Template, macro_name: str):
    """
        Gets the macro function from the template if found.

        :param template: The Jinja2 template object that contains the macro
        :type template: Jinja2.Template

        :param macro_name: The name of macro function needed
        :type macro_name: str

        :return: Macro as a python callable object
        :rtype: callable (jinja2.runtime.Macro)
    """
    try:
        macro = getattr(template.module, macro_name)
        return macro
    except AttributeError as e:
        if macro_name.startswith('_'):
            print(utils_messages.PRIVATE_MACRO_ERR.format(macro=macro_name))
        else:
            print(utils_messages.NO_MACRO_ERR.format(macro=macro_name, e=e))


def render_macro_json(macro, args: any) -> Dict:
    """
        Renders the jinja macro to python dictionary (json).

        :param macro: The jinja2 macro that can be rendered
        :type macro: callable

        :param args: Array of arguments that needs to be passed into the macro
        :type args: [any*]

        :return: Python dictionary
        :rtype: dict[str, any]
    """
    rendered_macro = render_macro_str(macro, args)
    try:
        output = json.loads(rendered_macro)
        return output
    except:
        print(utils_messages.INVALID_JSON_ERR.format(macro=macro))
        return


def render_macro_str(macro, args: any) -> str:
    """
        Renders jinja2 macros that returns a string.

        :param macro: The jinja2 macro that can be rendered
        :type macro: callable

        :param args: Array of arguments that needs to be passed into the macro
        :type args: [any*]

        :return: Macro string return value
        :rtype: str
    """
    try:
        rendered_macro = macro(*args)
        return rendered_macro
    except jinja2.exceptions.UndefinedError as e:
        print(utils_messages.MACRO_ARGS_ERR.format(e=e))
    except Exception as e:
        print(utils_messages.MACRO_RENDER_ERR.format(macro=macro, e=e))


def assert_json(output: Dict, expected: Dict) -> bool:
    """
        Asserts that the two python dictionaries are the same no matter the order.
        Sorts both dictionaries before checking.

        :param output: Output generated by jinja macro.
        :type output: dict[str, any]

        :param expected: Expected JSON for the jinja macro.
        :type expected: dict[str, any]

        :return: True if same and False otherwise
        :rtype: bool
    """
    if isinstance(output, dict) and isinstance(expected, dict):
        return ordered(output) == ordered(expected)
    else:
        print(utils_messages.INVALID_JSON_TYPE.format(
            expected_type=type(expected), output_type=type(output)))
        return False


def get_json_file(path: str, curr_method: str) -> Dict:
    """
        Reads in a JSON file and converts it to a Python dictionary.

        :param path: Absolute path to JSON file.
        :type path: str

        :param curr_method: The current unit test function name for error msgs
        :type curr_method: str

        :return: Python dictionary loaded from json file
        :rtype: dic
    """
    try:
        with open(path) as f:
            return json.load(f)
    except json.decoder.JSONDecodeError as e:
        print(utils_messages.JSON_DECODER_ERR.format(path=path, method=curr_method, e=e))
    except Exception as e:
        print(utils_messages.JSON_LOAD_ERR.format(path=path, method=curr_method, e=e))


def get_yaml_file(path: str, curr_method: str) -> Dict:
    """
        Reads in a YAML file and converts it to a Python dictionary.

        :param path: Absolute path to YAML file.
        :type path: str

        :param curr_method: The current unit test function name for error msgs
        :type curr_method: str

        :return: Python dictionary loaded from yaml file
        :rtype: dict
    """
    try:
        with open(path) as f:
            return yaml.load(f, Loader=yaml.FullLoader)
    except yaml.YAMLError as e:
        print(utils_messages.INVALID_YAML_ERR.format(path=path, method=curr_method, e=e))
    except Exception as e:
        print(utils_messages.YAML_LOAD_ERR.format(path=path, method=curr_method, e=e))


def ordered(obj: any) -> any:
    """
        Orders the python dictionary (also it's nested dictionaries) by it's keys or an array

        :param obj: Python dictionary or list
        :type obj: dic / list

        :return: Sorted dictionary or list
        :rtype: dic / list
    """
    if isinstance(obj, dict):
        return sorted((k, ordered(v)) for k, v in obj.items())
    elif isinstance(obj, list):
        return sorted(ordered(x) for x in obj)
    else:
        return obj


def assert_string(output: str, expected: str) -> bool:
    if isinstance(output, str) and isinstance(expected, str):
        return output.strip() == expected.strip()
    else:
        print(utils_messages.INVALID_STR_TYPE.format(
            expected_type=type(expected), output_type=type(output)))
        return False


def json_diff(output: Dict, expected: Dict, print_all: bool=True) -> Dict:
    """
        Does a deep diff between the output and expected JSON and returns the differences if any

        :param output: Output JSON
        :type output: dict[str, any]

        :param expected: Expected JSON
        :type expected: dict[str, any]

        :param print_all: Option to print output and expected along with the difference
        :type print_all: bool

        :return: Dictionary with just the different values
        :rtype: dic
    """
    if print_all:
        print(utils_messages.COMPARE_JSON_MSG.format(expected=expected, output=output))

    diff = DeepDiff(expected, output, report_repetition=True,
                    ignore_order=True)
    if diff != {}:
        print(utils_messages.DIFF_MSG.format(diff_map=json.dumps(
            diff, indent=4, default=str)))
    return diff

def _get_env(repository_root: str) -> jinja2.Environment:
    """
        Create a jinja environment. Only jinja template files within the environment may be accessed and used.

        :param repository_root: Absolute file path in which all needed template files are in
        :type repository_root: str

        :return: Jinja2 Environment
        :rtype: jinja2.Environment
    """

    env = jinja2.Environment(
        # All import/include paths are relative to the repository root
        loader=jinja2.FileSystemLoader(repository_root),
        # This forces errors for undefined variables and keys
        undefined=VeryStrictUndefined,
        extensions=[
            "jinja2.ext.do",                                # For "do"
            "jinja2.ext.loopcontrols",                      # For "break"/"continue"
            "j2test.filters.raise_extension.RaiseExtension",   # For "raise"
        ],
    )

    env.globals["assert"] = assert_func
    env.globals["regex_replace"] = regex_replace
    env.globals["readfromfile"] = read_from_file
    env.filters["frombase64"] = base64_decode
    env.filters["fromjson"] = from_json_filter
    env.filters["fromyaml"] = from_yaml_filter
    env.filters["hcl.stringify_dict"] = hcl.stringify_dict_filter
    env.filters["hcl.stringify_hcl_map"] = hcl.stringify_hcl_map_filter
    env.filters["jsonmerge"] = jsonmerge_filter
    env.filters["jsonpath"] = jsonpath_filter
    env.filters["tobase64"] = base64_encode
    env.filters["tojson"] = simple_to_json_filter
    env.filters["toyaml"] = to_yaml_filter
    env.filters["writetofile"] = write_to_file_filter

    return env